# Ключевые слова
* let
* where
* = 
* : 
* ,
* -> 
* import 
* ( )
* []
* null
* force

# Кратко об языке

Данный язык является функциональными, т.е.:
1. Отсутствие переменных, есть лишь аргументы функций
2. Наличие функций высшего порядка - принимающих как аргументы другие функции
3. Отсутствие циклов, есть только рекурсия
4. Ленивость вычислений - если что-то не понадобится, то оно не будет вычислено

Также данный язык является статические типизированным [С возможностью в будущем выводить большую часть типов, см. далее]:
1. Для всех аргументов функции явно указывается тип
2. Для всех функций явно указывается тип результата
3. В данном языке полностью отсутствует неявное преобразование типов

Данный язык должен иметь вывод типов, т.е. на примерах [TODO примеры кода до объяснения синтаксиса, вероятно надо оставить тут тезисы и расписать их где-то после объяснения основного синтакиса]:
1. Поскольку все базовые функции имеют возвращаемый тип, то можно выводить тип "нового" возвращаемого значения
```
let f(a: number, b: number) = a + b
# Оператор + у типа number возвращает number, следовательно функция f возвращает number 
```
2. Опять-таки поскольку все базовые функции имеют типы входных аргументов, то можно выводить типы текущих аргументов на основе аргументов используемых в базовых функциях
```
let g(a, b) = f(a, b) + 1
# Поскольку f принимает a и b типа number, то это ограничение накладывается на них и здесь
# Возвращаемый тип также выводится

let h(a, b) = a + b 
# В данном случае нельзя вывести ни возвращемый тип, ни типы для a и b 
# TODO обдумать систему на основе интерфейсов, и тогда типы тут можно выводить но общего вида (дженерики)

let j(a, b) = 1 + a + b 
# А вот тут можно явно вывести типы, поскольку число можно складывать только с числами
# TODO Но тут опять спорная ситуация, ибо подобное является какого-то рода неявным преобразованием
```
Данный язык имеет развитую систему типов, которая позволяет [А я корректо обзываю классы типами или нет?]:
1. Операторы, например такие, как +\\-\\*\\/ у чисел
2. Методы 
3. Иметь внутреннюю структуру данных у типа
4. Определять интерфейсы и реализовывать их
5. Осуществлять наследование от другого класса [Многотиповое наследование пока под вопросом]

Данный язык нейтрален к отступам, пробелам и переносам строки. Любое количество данных символов считается за 1 "пробельный символ".

# Функции
## Объявление функции

**TODO** переписать тип спика конкретней после определения работы дженериков
```
# Функция возвращает сумму всех элементов списка
let sum_array (arr: list) -> number = reduce(+, arr, 0)

# Функция возвращает сумму a и b 
let a+b -> number where 
    let a -> number = 1
    let b -> number = 2
= a + b
```
## Вызов функции
```
log("Привет, мир!")
# Привет, мир!

log(str(a+b())) 
# 3

log(str(1 + 2)) 
# 3
```
## Форсированный вызов функции:
В данном случае на экран никогда не будет выведена строка "Никогда" 
[log возвращает null, помимо вывода на экран]
```
let f -> null = if(
    false,
    log("Никогда"),
    log("Всегда")
)

f()
# Всегда
```
Но при применении форсирования(force) будут выведены оба значения еще до возврата значения из f [Которое будет null]
```
let f -> null = if(
    false,
    force log("Никогда"),
    force log("Всегда")
)

f()
# Никогда
# Всегда
```
# Типы данных

* number - число
* string - строка
* функция - **TODO** а тут надо подумать 
* list - список [**TODO** дженерики]
* null

# Модульная система
## Импорт локальных файлов 

**import** добавляет все функции из соответствующего файла в текущий, но только функции объявленные в глобальной видимости. 

**TODO** импорт лишь определенных функций(хотя парсить все равно надо будет все)

**TODO** продумать импорт библиотек

