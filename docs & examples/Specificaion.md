# Ключевые слова
* let
* where
* = 
* : 
* ,
* -> 
* import 
* ( )
* []
* null
* force

# Кратко об языке

Данный язык является функциональными, т.е.:
1. Отсутствие переменных, есть лишь аргументы функций
2. Наличие функций высшего порядка - принимающих как аргументы другие функции
3. Отсутствие управляющих конструкций(if, then, else, while, for, break, return)
4. Обязательная поддержка рекурсии
5. Ленивость вычислений - если что-то не понадобится, то оно не будет вычислено

Данныей язык имеет поддержку системы типов:
1. У типа описана стурктура данных
2. У типа есть операторы [Для их правильного парсинга придется парсить сначала объявления типов, а лишь затем реализацию конкретных операторов, функций и прочего]
    1. У операторов явно должен задаваться приоритет [количество уровней приоритета пока хз сколько, надо стандарты других языков посмотреть]
    2. [Префиксные операторы я пока не знаю как сделать, ибо тогда все будет зависеть от контекста вызова(имена у нас неограничены ничем, операторы тоже, и получается что будет то, что спарсится заранее), а так же пока не знаю как сделать оператры учитывая, что функции у нас связывались динамически, видимо придется отказаться от этого подхода и связывать функции на позднем этапе парсинга]
3. У типа нет методов, они выбиваются из синтаксиса языка и являются бесполезными в силу того, что у нас отсутствуют изменяемые данные
4. Определять интерфейсы и реализовывать их [пока под вопросом, но если будут интерфейсы, то подобные trait в Rust]
5. Осуществлять наследование от другого типа [Многотиповое наследование пока под вопросом]

Также данный язык является статические типизированным [С возможностью в будущем выводить большую часть типов, см. далее]:
1. Для всех аргументов функции явно указывается тип
2. Для всех функций явно указывается тип результата
3. В данном языке полностью отсутствует неявное преобразование типов

Данный язык должен иметь вывод типов, т.е. на примерах [TODO примеры кода до объяснения синтаксиса, вероятно надо оставить тут тезисы и расписать их где-то после объяснения основного синтакиса]:
1. Поскольку все базовые функции имеют возвращаемый тип, то можно выводить тип "нового" возвращаемого значения
```
let f(a: number, b: number) = a + b
# Оператор + у типа number возвращает number, следовательно функция f возвращает number 
```
2. Опять-таки поскольку все базовые функции имеют типы входных аргументов, то можно выводить типы текущих аргументов на основе аргументов используемых в базовых функциях
```
let g(a, b) = f(a, b) + 1
# Поскольку f принимает a и b типа number, то это ограничение накладывается на них и здесь
# Возвращаемый тип также выводится

let h(a, b) = a + b 
# В данном случае нельзя вывести ни возвращемый тип, ни типы для a и b 
# TODO обдумать систему на основе интерфейсов, и тогда типы тут можно выводить но общего вида (дженерики)

let j(a, b) = 1 + a + b 
# А вот тут можно явно вывести типы, поскольку число можно складывать только с числами
# TODO Но тут опять спорная ситуация, ибо подобное является какого-то рода неявным преобразованием
```

Данный язык должен иметь модульную систему, которая упростит анализ языка и позволит явно определять, какая функция или тип используется в конкретном месте:
1. Позволяет определять функции или типы с одинаковым именем в разных модулях
2. Обязывает явно указывать модуль, из которого используется функция или метод [со стандартной библиотекой я пока хз] 
3. Позволяет указывать какие элементы модуля будут доступны извне, а какие -- нет 

Данный язык нейтрален к отступам, пробелам и переносам строки. Любое количество данных символов считается за 1 "пробельный символ".

# Функции
## Объявление функции

**TODO** переписать тип спика конкретней после определения работы дженериков
```
# Функция возвращает сумму всех элементов списка
let sum_array (arr: list) -> number = reduce(+, arr, 0)

# Функция возвращает сумму a и b 
let a+b -> number where 
    let a -> number = 1
    let b -> number = 2
= a + b
```
## Вызов функции
```
log("Привет, мир!")
# Привет, мир!

log(str(a+b())) 
# 3

log(str(1 + 2)) 
# 3
```
## Форсированный вызов функции:
В данном случае на экран никогда не будет выведена строка "Никогда" 
[log возвращает null, помимо вывода на экран]
```
let f -> null = if(
    false,
    log("Никогда"),
    log("Всегда")
)

f()
# Всегда
```
Но при применении форсирования(force) будут выведены оба значения еще до возврата значения из f [Которое будет null]
```
let f -> null = if(
    false,
    force log("Никогда"),
    force log("Всегда")
)

f()
# Никогда
# Всегда
```
# Типы данных

* number - число
* string - строка
* функция - **TODO** а тут надо подумать 
* list - список [**TODO** дженерики]
* null

# Модульная система
## Импорт локальных файлов 

**import** добавляет все функции из соответствующего файла в текущий, но только функции объявленные в глобальной видимости. 

**TODO** импорт лишь определенных функций(хотя парсить все равно надо будет все)

**TODO** продумать импорт библиотек

